require 'fiber'

module Argot

    # Base for a stage (step) in a data processing pipeline
    #
    # == Attributes:
    #  source::
    #    the previous stage in the pipeline
    #  name::
    #    a (friendly?) name to use when displaying information about
    #    the stage
    #
    # Typically you will not need to use or subclass this class, but 
    # it holds the base functionality.
    #
    # Each instance of this class wraps a *Fiber*, and some of that
    # implementation detail leaks, e.g. the #resume method. 
    #
    # Conceptually, each stage is responsible for asking its input to
    # yield the next value to be processed.  Once the stage has done
    # its processing, it will yield its value (and control) to the
    # next stage.  This allows each record to be sent through the pipeline 
    # individually, at the pace allowed by the slowest processing
    # stagea
    #
    # A stage's Fiber 'ends' once it receives (not *catches*!) 
    # StopIteration at its input.
    class Stage 
        attr_accessor :source, :name

        # intiializes this instance
        # @param the options for this instance.  Generally
        # subclass-dependent with the exception of the :name
        # attribute.
        # @param &block the block that implements the processing
        #        logic for this stage
        def initialize(options = {},&block)
            @transformer ||= method(:transform)
            @filter ||= method(:filter)
            @fiber_delegate = Fiber.new do
                process
            end
            options.each do |k,v|
                send "#{k}=", v
            end
        end

        # Chains the output of this stage to a subsequent stage
        # @param next_stage the next stage in processing
        def |(next_stage)
            next_stage.source = self
            next_stage 
        end

        # Resumes the Fiber underlying this instance, preparing 
        # it to process the next record.
        def resume
            if @fiber_delegate.alive?
                @fiber_delegate.resume
            else
                raise StopIteration
            end
        end

        def process
            while ( value = input )
                handle_value(value)
            end
        end

        # pull the next value from the previous stage
        def input
            self.source.resume
        end

        # send the result of this stage to the next stage
        # @param value the result generated by this stage.
        def output(value)
            Fiber.yield(value)
        end

        # Processes the current value and call #output
        # with the result unless the result should be filtered 
        def handle_value(value)
            if value == StopIteration
                raise StopIteration
            else
                output(@transformer.call(value)) if @filter.call(value)
            end
        end

        # performs the transformation of the input value
        # @param value the value provided to this stage
        # @return the transformed result; in the base class, this is
        #
        def transform(value)
            value
        end

        # Tests whether the value provided to this stage should be passed
        # on to the next stage
        # @param value [Object] the value to be processed
        # @return true if the value passes the filter, false if not.
        def filter(value)
            true
        end

        def inspect 
            "Stage(#{self.name})"
        end
        
        # Gets the stages from this one back to the first one in 
        # the chain.  May be of use in debugging.
        def path 
            result = [self] 
            result << self.source.path unless self.source.nil?
            result.flatten
        end

    end

    # Base class for a stage that filters results without otherwise
    # processing them.
    # @param &block a block that returns true for results that should
    # be passed down the pipeline, and false for results that should not
    class Filter < Stage
        def initialize(options={},&block)
            options[:name] ||= "filter"
            @filter = block
            super
        end
    end

    # Base class for a stage that transforms results passed into it
    # @param &block a block whose return value will be passed to subsequent
    #        stages.
    class Transformer < Stage
        def initialize(options={},&block)
            options[:name] ||= "transformer"
            @transformer = block
            super
        end
    end

    # Builder that implements the DSL for pipeline construction.
    # The primary use for this class is to provide standardized constructors
    # for pipeline stages, which is used as the basis for a DSL.
    #
    # The fundamental job of this class is to evaluate a block and
    # populate the `stages` attribute, which will be wired together
    # into a pipeline by Pipeline#setup
    class Builder

        # the stages, in the original order 
        attr_reader :stages

        def initialize
            @stages = []
        end

        # Constructs a filter given a block (and any options)
        def filter(options={}, &block)
            check_options(options)
            @stages << Filter.new(options,&block)
        end

        # Constructs a Transformer instance given a block
        # (and any options)
        def transform(options={},&block)
            check_options(options)
            @stages << Transformer.new(options,&block)
        end

        # filter that rejects nil values
        def nonnil
            filter({:name=>"Filter blanks"}) { |x| not x.nil? }
        end

        # @return the result of calling #upcase on input strings
        def upcase 
            transform({:name=>"Upper case"}) {|x| x.upcase}
        end

        private

        # ensures that options are reasonable, e.g. adding
        # a name for the stage if one was not supplied.
        def check_options(type,options={})
            options[:name] ||= "#{type}-#{@stages.length+1}"
        end
    end

    # A processing chain composed of multiple stages.
    # Objects fed into the pipeline (via an Enumerable object)
    # are sent through its stages as specified in the documentation of
    # Stage and its subclasses when the pipeline's #run() method is called.
    #
    # Pipelines can be constructed in one of two ways, one inspired
    # by the command line and one using a Domain Specific Language (DSL).
    #
    # UNIX pipe-inspired:
    #
    # # reject all nil values
    #   nil_filter = Filter.new( {|x| not x.nil? })
    #   downcase_transformer = Transformer.new({ |x| x.downcase })
    #   words = [ 'thiS', nil, 'IS', 'THE', 'sTory', nil, 'oF', 'tRLn' ]
    #
    #   p = Pipeline.new | nil_filter | downcase_transformer 
    #   p.run(words) { |x| puts x }  
    #   # prints "this is the story  of trln" one word per line
    #
    # Alternately, use the DSL; this should be more approachable than the 
    # above, and provides some syntactic niceties:
    # 
    #   p = Pipeline.setup {
    #       nonnil
    #       upcase
    #   }
    #
    #   p.run(words) { |x| puts x } 
    #   # same output as above, but upper-cased
    #
    # In this first DSL example, `nonnil` and `upcase` are mnemonics for a 
    # "non-nil" Filter and upper-casing Transformer.  More generic mnemonics
    # are also available to allow you to supply your own filter/transformer
    # blocks, so the following is (nearly) equivalent:
    #
    #   p = Pipeline.setup {
    #       filter { |x| not x.nil? }
    #       transform { |x| x.upcase }
    #   }
    #   # the difference from the named stage example is that the stages
    #     will have different names, but this only matters when you want to 
    #     view the pipeline.
    #
    #   # as above ...
    #
    # "Named" filters and transformers are defined in the Builder class.
    #
    # See the Builder class above for more info about how to add named
    # filters and transformers.
    #
    # @todo more serious examples, perhaps involving stateful stages
    # @todo come up with an elegant way of adding new named stages
    #       for the DSL.
    #
    # Implementation inspired by UNIX pipes and, more directly,
    #
    # by Dave Thomas' series
    # https://pragdave.me/blog/2007/12/30/pipelines-using-fibers-in-ruby-19/
    # https://pragdave.me/blog/2008/01/01/pipelines-using-fibers-in-ruby-19part-ii/
    class Pipeline

        attr_reader :enumerable

        def initialize(enumerable=[].each)
            self.enumerable = enumerable
            @last_stage = self
        end

        
        def |(next_stage)
            if @last_stage != self 
                @last_stage | next_stage
            else 
                next_stage.source=self
            end
            @last_stage = next_stage
            self
        end

        def enumerable=(something)
            if something.respond_to?(:next)
                @enumerable = something
            else
                @enumerable = something.each.lazy
            end
            @delegate_fiber = Fiber.new do
                while v = @enumerable.next
                    Fiber.yield v
                end
            end
        end

        def resume
            @delegate_fiber.resume
        end

        def name
            "(start)"
        end

        def source
         nil
        end

        def path
            []
        end

        # displays the pipeline 
        def debug
            stages = @last_stage.path.reverse!
            " (input) ->" << stages.collect { |x| x.name }.join(" -> ") << " -> (output)"
        end

        # Executes the pipeline, processing each end result with
        # a supplied block
        # @param local_enumberable (optional) an enumerable or array whose 
        #   members will be fed into the pipeline.
        # @yield [Object, nil] the result of the final stage of the pipeline.
        def run(local_enumerable=nil)
            self.enumerable = local_enumerable unless local_enumerable.nil?    
            loop do
                begin
                    yield @last_stage.resume
                rescue StopIteration
                    break
                end
            end
        end

        # Build a pipeline using the DSL. 
        # @param builder_class the class that provides the 
        #   named stages, should probably be a subclass of Builder
        #   (the default) unless you have special needs.
        # @param &block that which will be evaluated by a fresh instance
        #        of `builder_class` to create the stages of the pipeline.
        def self.setup(builder_class=Builder,&block) 
            builder = builder_class.new
            builder.instance_eval(&block)
            result = Pipeline.new([])
            builder.stages.each { |stage| result | stage }
            result
        end
    end
end
